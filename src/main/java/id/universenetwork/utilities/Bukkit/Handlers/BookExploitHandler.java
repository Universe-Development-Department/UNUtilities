package id.universenetwork.utilities.Bukkit.Handlers;

import id.universenetwork.utilities.Bukkit.Commands.Filter;
import id.universenetwork.utilities.Bukkit.Filters.BookFilter;
import id.universenetwork.utilities.Bukkit.Filters.FilterAction;
import id.universenetwork.utilities.Bukkit.Hooks.AntiBookExploit;
import id.universenetwork.utilities.Bukkit.Listeners.AntiBookExploitListener;
import id.universenetwork.utilities.Bukkit.Matcher.WildcardMatcher;
import id.universenetwork.utilities.Bukkit.Utils.Version;
import net.md_5.bungee.api.chat.ClickEvent.Action;
import org.bukkit.World;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.stream.Collectors;

import static id.universenetwork.utilities.Bukkit.Enums.Features.AntiBookExploit.*;
import static id.universenetwork.utilities.Bukkit.Manager.Color.Translator;
import static id.universenetwork.utilities.Bukkit.Manager.Config.get;
import static org.bukkit.Bukkit.getBukkitVersion;
import static org.bukkit.Bukkit.getPluginManager;

public class BookExploitHandler {
    static final String PATH_FILTER_CONTENT = FILTER_CONTENT.getConfigPath();
    static final String PATH_CHECK_CREATION = CHECK_CREATION.getConfigPath();
    static final String PATH_CHECK_READING = CHECK_READING.getConfigPath();
    static final String PATH_PERMITTED_CONTENT = PERMITTED_CONTENT.getConfigPath();
    static final String PATH_WORLD_WHITELIST = WORLD_WHITELIST.getConfigPath();
    static final String PATH_PLAYER_MESSAGE = PLAYER_MESSAGE.getConfigPath();
    static Set<Action> filterActions;
    static boolean checkCreation;
    static boolean checkReading;
    public static boolean lecternSupport = false;
    static List<String> worldWhitelist;
    static WildcardMatcher permittedContent;
    static String playerMessage;

    public BookExploitHandler() {
        setup();
        BookFilter bookFilter = new BookFilter(filterActions, this);
        new AntiBookExploitListener(this, bookFilter);
        if (getPluginManager().isPluginEnabled("ProtocolLib")) AntiBookExploit.activate(bookFilter, this);
        new Filter(bookFilter);
    }

    public static void setup() {
        filterActions = EnumSet.copyOf(Arrays.stream(Action.values()).filter(action -> Objects.requireNonNull(get().getConfigurationSection(PATH_FILTER_CONTENT), "Missing configuration section " + PATH_FILTER_CONTENT).getBoolean(action.name().toLowerCase(Locale.US), false)).collect(Collectors.toSet()));
        checkCreation = get().getBoolean(PATH_CHECK_CREATION, true);
        checkReading = get().getBoolean(PATH_CHECK_READING, true);
        List<String> worldWhiteList = get().getStringList(PATH_WORLD_WHITELIST);
        worldWhitelist = worldWhiteList.isEmpty() ? null : worldWhiteList;
        permittedContent = new WildcardMatcher(get().getStringList(PATH_PERMITTED_CONTENT));
        final String rawMessage = get().getString(PATH_PLAYER_MESSAGE);
        if (rawMessage != null && !rawMessage.trim().isEmpty()) playerMessage = Translator(rawMessage);
        else playerMessage = null;
        Version minLecternVersion = new Version(1, 14, 0);
        Version serverVersion = Version.parseVersion(getBukkitVersion());
        final boolean enableLectern;
        if (serverVersion != null) enableLectern = minLecternVersion.compareTo(serverVersion) <= 0;
        else enableLectern = false;
        if (enableLectern) lecternSupport = true;
    }

    @NotNull
    public Set<Action> getFilterActions() {
        return filterActions;
    }

    public boolean isWorldDisabled(World world) {
        return worldWhitelist != null && !worldWhitelist.contains(world.getName());
    }

    public boolean isContentPermitted(String content) {
        return permittedContent.matches(content);
    }

    @Nullable
    public String getPlayerMessage() {
        return playerMessage;
    }

    public boolean checkAction(FilterAction action) {
        switch (action) {
            case READ:
                return checkReading;
            case CREATE:
                return checkCreation;
            default:
                return true;
        }
    }

    @Nullable
    public static String limitLoggingString(@Nullable final String input) {
        if (input == null) return null;
        else return input.substring(0, Math.min(1500, input.length()));
    }
}